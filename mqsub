#!/usr/bin/env python3

# Script to more easily submit jobs to the QUT HPC queuing system

# Must be python3.4-compatible since that is what is on the lyra base

__author__ = "Ben Woodcroft"
__copyright__ = "Copyright 2020"
__credits__ = ["Ben Woodcroft"]
__license__ = "GPL3"
__maintainer__ = "Ben Woodcroft"
__email__ = "benjwoodcroft near gmail.com"
__status__ = "Development"

import argparse
import logging
import sys
import os
import tempfile
import subprocess
import getpass
import shutil

## Code below copied from the extern python package. Copy the code here so there are no dependencies.

def run(command, stdin=None):
    '''
    Run a subprocess.check_output() with the given command with
    'bash -c command'
    returning the stdout. If the command fails (i.e. has a non-zero exitstatus),
    raise a ExternCalledProcessError that includes the $stderr as part of
    the error message

    Parameters
    ----------
    command: str
        command to run
    stdin: str or None
        stdin to be provided to the process, to subprocess.communicate.

    Returns
    -------
    Standard output of the run command

    Exceptions
    ----------
    extern.ExternCalledProcessError including stdout and stderr of the run
    command should it return with non-zero exit status.
    '''
    #logging.debug("Running extern cmd: %s" % command)

    using_stdin = stdin is not None
    process = process = subprocess.Popen(
        ["bash",'-o','pipefail',"-c", command],
        stdin= (subprocess.PIPE if using_stdin else None),
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate(stdin)

    if process.returncode != 0:
        raise ExternCalledProcessError(process, command)
    return stdout

class ExternCalledProcessError(subprocess.CalledProcessError):
    def __init__(self, completed_process, command):
        self.command = command
        self.returncode = completed_process.returncode
        self.stderr = completed_process.stderr
        self.stdout = completed_process.stdout
        self.completed_process = completed_process

    def __str__(self):
        return "Command %s returned non-zero exit status %i.\n"\
            "STDERR was: %sSTDOUT was: %s" % (self.command,
                                                self.returncode,
                                                self.stderr,
                                                self.stdout)




if __name__ == '__main__':
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--debug', help='output debug information', action="store_true")
    #parser.add_argument('--version', help='output version information and quit',  action='version', version=repeatm.__version__)
    parser.add_argument('--quiet', help='only output errors', action="store_true")

    #parser.add_argument("-c", "--conda_environment", "--conda-environment", help="Load this conda environment")

    parser.add_argument('-t','--cpus',default=1,type=int, help="Number of CPUs to queue job with [default: 1]")
    parser.add_argument('-m','--mem','--ram',default=4,type=int, help="GB of RAM to ask for [default: 4]")
    parser.add_argument('--hours',default=24*7,type=int, help="Hours to run for [default: 1 week]")
    parser.add_argument('--name', help="Name of the job [default: first word of command]")
    parser.add_argument('--dry-run',action='store_true', help="Print script to STDOUT and do not lodge it with qsub")
    parser.add_argument('command',nargs='+',help='command to be run')

    # for (i, arg) in sys.argv:
    #     if arg == '--':
    #         cmd = sys.argv[i+1:]
    #         predash_arguments = sys.argv[:i]

    # if cmd is None:
    #     parser.parse_args('')
    #     cmd = args.command
    # else:
    args = parser.parse_args()

    # Setup logging
    if args.debug:
        loglevel = logging.DEBUG
    elif args.quiet:
        loglevel = logging.ERROR
    else:
        loglevel = logging.INFO
    logging.basicConfig(level=loglevel, format='%(asctime)s %(levelname)s: %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')

    with tempfile.NamedTemporaryFile(prefix='mqsub_script',suffix='.sh',mode='w') as tf:
        if args.dry_run:
            tf = sys.stdout

        cmd = args.command
        if args.name:
            jobname = args.name
        else:
            jobname = cmd[0]
        logging.debug("Naming job as: {}".format(jobname))

        whoami = getpass.getuser()
        email = '{}@qut.edu.au'.format(whoami)
        logging.debug("Using email address: {}".format(email))

        exe = cmd[0]
        logging.debug("Testing if executable {} is available in $PATH".format(exe))
        if shutil.which(exe) is None:
            raise Exception("The executable {} is not available, not continuing".format(exe))
        logging.debug("Executable was available, seems all good")

        print('#!/bin/bash -l',file=tf)
        print('#PBS -N {}'.format(jobname),file=tf)
        print('#PBS -l ncpus={}'.format(args.cpus),file=tf)
        print('#PBS -l mem={}gb'.format(args.mem),file=tf)
        print('#PBS -l walltime={}:00:00'.format(args.hours),file=tf)
        print('#PBS -m ae',file=tf)
        print('#PBS -M {}'.format(email),file=tf)

        # cd to current directory
        print("cd '{}'".format(os.getcwd()), file=tf)

        # activate the conda environment from which this script was started
        current_conda_env = os.environ['CONDA_PREFIX']
        if current_conda_env:
            print('. /pkg/suse12/software/miniconda3/4.5.12/etc/profile.d/conda.sh',file=tf)
            print('conda activate',file=tf)
            print("source activate '{}'".format(current_conda_env),file=tf)
        
        print(' '.join(cmd),file=tf)
        tf.flush()

        if args.dry_run:
            logging.info("Not running qsub since this is a dry run")
        else:
            qsub_stdout = run("qsub {}".format(tf.name))
            print("qsub stdout: {}".format(qsub_stdout), file=sys.stderr)
